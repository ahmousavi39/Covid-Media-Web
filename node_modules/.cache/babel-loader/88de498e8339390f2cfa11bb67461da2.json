{"ast":null,"code":"import _toConsumableArray from \"/home/workspace/Desktop/Files/Projects/Programming/Working On/Covid Media/Web/covidmedia_v.3.1.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/home/workspace/Desktop/Files/Projects/Programming/Working On/Covid Media/Web/covidmedia_v.3.1.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cacheGet, cacheSet } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\n\nvar pageCacheMap = new Map();\nexport function useSWRPages(pageKey, pageFn, SWRToOffset) {\n  var deps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var pageCountKey = \"_swr_page_count_\" + pageKey;\n  var pageOffsetKey = \"_swr_page_offset_\" + pageKey;\n\n  var _useState = useState(cacheGet(pageCountKey) || 1),\n      _useState2 = _slicedToArray(_useState, 2),\n      pageCount = _useState2[0],\n      setPageCount = _useState2[1];\n\n  var _useState3 = useState(cacheGet(pageOffsetKey) || [null]),\n      _useState4 = _slicedToArray(_useState3, 2),\n      pageOffsets = _useState4[0],\n      setPageOffsets = _useState4[1];\n\n  var _useState5 = useState([]),\n      _useState6 = _slicedToArray(_useState5, 2),\n      pageSWRs = _useState6[0],\n      setPageSWRs = _useState6[1];\n\n  var pageFnRef = useRef(pageFn);\n  var emptyPageRef = useRef(false); // Page component (wraps `pageFn`)\n  // for performance reason we need to memorize it\n\n  var Page = useCallback(function (props) {\n    // render the page component\n    var dataList = pageFnRef.current(props); // if dataList is [], we can assume this page is empty\n    // TODO: this API is not stable\n\n    if (dataList && !dataList.length) {\n      emptyPageRef.current = true;\n    } else {\n      emptyPageRef.current = false;\n    }\n\n    return dataList;\n  }, []); // Doesn't have a next page\n\n  var isReachingEnd = pageOffsets[pageCount] === null;\n  var isLoadingMore = pageCount === pageOffsets.length;\n  var isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n  var loadMore = useCallback(function () {\n    if (isLoadingMore || isReachingEnd) return;\n    setPageCount(function (c) {\n      cacheSet(pageCountKey, c + 1);\n      return c + 1;\n    });\n  }, [isLoadingMore || isReachingEnd]);\n\n  var _pageFn = useCallback(pageFn, deps);\n\n  pageFnRef.current = _pageFn;\n  var pages = useMemo(function () {\n    var getWithSWR = function getWithSWR(id) {\n      return function (swr) {\n        if (!pageSWRs[id] || pageSWRs[id].data !== swr.data || pageSWRs[id].error !== swr.error || pageSWRs[id].revalidate !== swr.revalidate) {\n          setPageSWRs(function (swrs) {\n            var _swrs = _toConsumableArray(swrs);\n\n            _swrs[id] = {\n              data: swr.data,\n              error: swr.error,\n              revalidate: swr.revalidate,\n              isValidating: swr.isValidating,\n              mutate: swr.mutate\n            };\n            return _swrs;\n          });\n\n          if (typeof swr.data !== 'undefined') {\n            // set next page's offset\n            var newPageOffset = SWRToOffset(swr, id);\n\n            if (pageOffsets[id + 1] !== newPageOffset) {\n              setPageOffsets(function (arr) {\n                var _arr = _toConsumableArray(arr);\n\n                _arr[id + 1] = newPageOffset;\n                cacheSet(pageOffsetKey, _arr);\n                return _arr;\n              });\n            }\n          }\n        }\n\n        return swr;\n      };\n    }; // render each page\n\n\n    var p = [];\n\n    if (!pageCacheMap.has(pageKey)) {\n      pageCacheMap.set(pageKey, []);\n    }\n\n    var pageCache = pageCacheMap.get(pageKey);\n\n    for (var i = 0; i < pageCount; ++i) {\n      if (!pageCache[i] || pageCache[i].offset !== pageOffsets[i] || pageCache[i].pageFn !== _pageFn) {\n        // when props change or at init\n        // render the page and cache it\n        pageCache[i] = {\n          component: React.createElement(Page, {\n            key: \"page-\".concat(pageOffsets[i], \"-\").concat(i),\n            offset: pageOffsets[i],\n            withSWR: getWithSWR(i)\n          }),\n          pageFn: _pageFn,\n          offset: pageOffsets[i]\n        };\n      }\n\n      p.push(pageCache[i].component);\n    }\n\n    return p;\n  }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n  return {\n    pages: pages,\n    pageCount: pageCount,\n    pageSWRs: pageSWRs,\n    isLoadingMore: isLoadingMore,\n    isReachingEnd: isReachingEnd,\n    isEmpty: isEmpty,\n    loadMore: loadMore\n  };\n}","map":{"version":3,"sources":["/home/workspace/Desktop/Files/Projects/Programming/Working On/Covid Media/Web/covidmedia_v.3.1.0/node_modules/swr/esm/use-swr-pages.js"],"names":["React","useCallback","useMemo","useState","useRef","cacheGet","cacheSet","pageCacheMap","Map","useSWRPages","pageKey","pageFn","SWRToOffset","deps","pageCountKey","pageOffsetKey","pageCount","setPageCount","pageOffsets","setPageOffsets","pageSWRs","setPageSWRs","pageFnRef","emptyPageRef","Page","props","dataList","current","length","isReachingEnd","isLoadingMore","isEmpty","loadMore","c","_pageFn","pages","getWithSWR","id","swr","data","error","revalidate","swrs","_swrs","isValidating","mutate","newPageOffset","arr","_arr","p","has","set","pageCache","get","i","offset","component","createElement","key","withSWR","push"],"mappings":"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","sourcesContent":["import React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cacheGet, cacheSet } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\nconst pageCacheMap = new Map();\nexport function useSWRPages(pageKey, pageFn, SWRToOffset, deps = []) {\n    const pageCountKey = `_swr_page_count_` + pageKey;\n    const pageOffsetKey = `_swr_page_offset_` + pageKey;\n    const [pageCount, setPageCount] = useState(cacheGet(pageCountKey) || 1);\n    const [pageOffsets, setPageOffsets] = useState(cacheGet(pageOffsetKey) || [null]);\n    const [pageSWRs, setPageSWRs] = useState([]);\n    const pageFnRef = useRef(pageFn);\n    const emptyPageRef = useRef(false);\n    // Page component (wraps `pageFn`)\n    // for performance reason we need to memorize it\n    const Page = useCallback(props => {\n        // render the page component\n        const dataList = pageFnRef.current(props);\n        // if dataList is [], we can assume this page is empty\n        // TODO: this API is not stable\n        if (dataList && !dataList.length) {\n            emptyPageRef.current = true;\n        }\n        else {\n            emptyPageRef.current = false;\n        }\n        return dataList;\n    }, []);\n    // Doesn't have a next page\n    const isReachingEnd = pageOffsets[pageCount] === null;\n    const isLoadingMore = pageCount === pageOffsets.length;\n    const isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n    const loadMore = useCallback(() => {\n        if (isLoadingMore || isReachingEnd)\n            return;\n        setPageCount(c => {\n            cacheSet(pageCountKey, c + 1);\n            return c + 1;\n        });\n    }, [isLoadingMore || isReachingEnd]);\n    const _pageFn = useCallback(pageFn, deps);\n    pageFnRef.current = _pageFn;\n    const pages = useMemo(() => {\n        const getWithSWR = id => swr => {\n            if (!pageSWRs[id] ||\n                pageSWRs[id].data !== swr.data ||\n                pageSWRs[id].error !== swr.error ||\n                pageSWRs[id].revalidate !== swr.revalidate) {\n                setPageSWRs(swrs => {\n                    const _swrs = [...swrs];\n                    _swrs[id] = {\n                        data: swr.data,\n                        error: swr.error,\n                        revalidate: swr.revalidate,\n                        isValidating: swr.isValidating,\n                        mutate: swr.mutate\n                    };\n                    return _swrs;\n                });\n                if (typeof swr.data !== 'undefined') {\n                    // set next page's offset\n                    const newPageOffset = SWRToOffset(swr, id);\n                    if (pageOffsets[id + 1] !== newPageOffset) {\n                        setPageOffsets(arr => {\n                            const _arr = [...arr];\n                            _arr[id + 1] = newPageOffset;\n                            cacheSet(pageOffsetKey, _arr);\n                            return _arr;\n                        });\n                    }\n                }\n            }\n            return swr;\n        };\n        // render each page\n        const p = [];\n        if (!pageCacheMap.has(pageKey)) {\n            pageCacheMap.set(pageKey, []);\n        }\n        const pageCache = pageCacheMap.get(pageKey);\n        for (let i = 0; i < pageCount; ++i) {\n            if (!pageCache[i] ||\n                pageCache[i].offset !== pageOffsets[i] ||\n                pageCache[i].pageFn !== _pageFn) {\n                // when props change or at init\n                // render the page and cache it\n                pageCache[i] = {\n                    component: (React.createElement(Page, { key: `page-${pageOffsets[i]}-${i}`, offset: pageOffsets[i], withSWR: getWithSWR(i) })),\n                    pageFn: _pageFn,\n                    offset: pageOffsets[i]\n                };\n            }\n            p.push(pageCache[i].component);\n        }\n        return p;\n    }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n    return {\n        pages,\n        pageCount,\n        pageSWRs,\n        isLoadingMore,\n        isReachingEnd,\n        isEmpty,\n        loadMore\n    };\n}\n"]},"metadata":{},"sourceType":"module"}