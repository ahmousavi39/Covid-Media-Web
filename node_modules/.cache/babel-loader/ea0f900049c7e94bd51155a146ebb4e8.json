{"ast":null,"code":"import React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cacheGet, cacheSet } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\n\nconst pageCacheMap = new Map();\nexport function useSWRPages(pageKey, pageFn, SWRToOffset, deps = []) {\n  const pageCountKey = `_swr_page_count_` + pageKey;\n  const pageOffsetKey = `_swr_page_offset_` + pageKey;\n  const [pageCount, setPageCount] = useState(cacheGet(pageCountKey) || 1);\n  const [pageOffsets, setPageOffsets] = useState(cacheGet(pageOffsetKey) || [null]);\n  const [pageSWRs, setPageSWRs] = useState([]);\n  const pageFnRef = useRef(pageFn);\n  const emptyPageRef = useRef(false); // Page component (wraps `pageFn`)\n  // for performance reason we need to memorize it\n\n  const Page = useCallback(props => {\n    // render the page component\n    const dataList = pageFnRef.current(props); // if dataList is [], we can assume this page is empty\n    // TODO: this API is not stable\n\n    if (dataList && !dataList.length) {\n      emptyPageRef.current = true;\n    } else {\n      emptyPageRef.current = false;\n    }\n\n    return dataList;\n  }, []); // Doesn't have a next page\n\n  const isReachingEnd = pageOffsets[pageCount] === null;\n  const isLoadingMore = pageCount === pageOffsets.length;\n  const isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n  const loadMore = useCallback(() => {\n    if (isLoadingMore || isReachingEnd) return;\n    setPageCount(c => {\n      cacheSet(pageCountKey, c + 1);\n      return c + 1;\n    });\n  }, [isLoadingMore || isReachingEnd]);\n\n  const _pageFn = useCallback(pageFn, deps);\n\n  pageFnRef.current = _pageFn;\n  const pages = useMemo(() => {\n    const getWithSWR = id => swr => {\n      if (!pageSWRs[id] || pageSWRs[id].data !== swr.data || pageSWRs[id].error !== swr.error || pageSWRs[id].revalidate !== swr.revalidate) {\n        setPageSWRs(swrs => {\n          const _swrs = [...swrs];\n          _swrs[id] = {\n            data: swr.data,\n            error: swr.error,\n            revalidate: swr.revalidate,\n            isValidating: swr.isValidating,\n            mutate: swr.mutate\n          };\n          return _swrs;\n        });\n\n        if (typeof swr.data !== 'undefined') {\n          // set next page's offset\n          const newPageOffset = SWRToOffset(swr, id);\n\n          if (pageOffsets[id + 1] !== newPageOffset) {\n            setPageOffsets(arr => {\n              const _arr = [...arr];\n              _arr[id + 1] = newPageOffset;\n              cacheSet(pageOffsetKey, _arr);\n              return _arr;\n            });\n          }\n        }\n      }\n\n      return swr;\n    }; // render each page\n\n\n    const p = [];\n\n    if (!pageCacheMap.has(pageKey)) {\n      pageCacheMap.set(pageKey, []);\n    }\n\n    const pageCache = pageCacheMap.get(pageKey);\n\n    for (let i = 0; i < pageCount; ++i) {\n      if (!pageCache[i] || pageCache[i].offset !== pageOffsets[i] || pageCache[i].pageFn !== _pageFn) {\n        // when props change or at init\n        // render the page and cache it\n        pageCache[i] = {\n          component: React.createElement(Page, {\n            key: `page-${pageOffsets[i]}-${i}`,\n            offset: pageOffsets[i],\n            withSWR: getWithSWR(i)\n          }),\n          pageFn: _pageFn,\n          offset: pageOffsets[i]\n        };\n      }\n\n      p.push(pageCache[i].component);\n    }\n\n    return p;\n  }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n  return {\n    pages,\n    pageCount,\n    pageSWRs,\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  };\n}","map":{"version":3,"sources":["/home/workspace/Desktop/Files/Projects/Programming/Working On/Covid Media/Web/covidmedia_v.3.1.0/node_modules/swr/esm/use-swr-pages.js"],"names":["React","useCallback","useMemo","useState","useRef","cacheGet","cacheSet","pageCacheMap","Map","useSWRPages","pageKey","pageFn","SWRToOffset","deps","pageCountKey","pageOffsetKey","pageCount","setPageCount","pageOffsets","setPageOffsets","pageSWRs","setPageSWRs","pageFnRef","emptyPageRef","Page","props","dataList","current","length","isReachingEnd","isLoadingMore","isEmpty","loadMore","c","_pageFn","pages","getWithSWR","id","swr","data","error","revalidate","swrs","_swrs","isValidating","mutate","newPageOffset","arr","_arr","p","has","set","pageCache","get","i","offset","component","createElement","key","withSWR","push"],"mappings":"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","sourcesContent":["import React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cacheGet, cacheSet } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\nconst pageCacheMap = new Map();\nexport function useSWRPages(pageKey, pageFn, SWRToOffset, deps = []) {\n    const pageCountKey = `_swr_page_count_` + pageKey;\n    const pageOffsetKey = `_swr_page_offset_` + pageKey;\n    const [pageCount, setPageCount] = useState(cacheGet(pageCountKey) || 1);\n    const [pageOffsets, setPageOffsets] = useState(cacheGet(pageOffsetKey) || [null]);\n    const [pageSWRs, setPageSWRs] = useState([]);\n    const pageFnRef = useRef(pageFn);\n    const emptyPageRef = useRef(false);\n    // Page component (wraps `pageFn`)\n    // for performance reason we need to memorize it\n    const Page = useCallback(props => {\n        // render the page component\n        const dataList = pageFnRef.current(props);\n        // if dataList is [], we can assume this page is empty\n        // TODO: this API is not stable\n        if (dataList && !dataList.length) {\n            emptyPageRef.current = true;\n        }\n        else {\n            emptyPageRef.current = false;\n        }\n        return dataList;\n    }, []);\n    // Doesn't have a next page\n    const isReachingEnd = pageOffsets[pageCount] === null;\n    const isLoadingMore = pageCount === pageOffsets.length;\n    const isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n    const loadMore = useCallback(() => {\n        if (isLoadingMore || isReachingEnd)\n            return;\n        setPageCount(c => {\n            cacheSet(pageCountKey, c + 1);\n            return c + 1;\n        });\n    }, [isLoadingMore || isReachingEnd]);\n    const _pageFn = useCallback(pageFn, deps);\n    pageFnRef.current = _pageFn;\n    const pages = useMemo(() => {\n        const getWithSWR = id => swr => {\n            if (!pageSWRs[id] ||\n                pageSWRs[id].data !== swr.data ||\n                pageSWRs[id].error !== swr.error ||\n                pageSWRs[id].revalidate !== swr.revalidate) {\n                setPageSWRs(swrs => {\n                    const _swrs = [...swrs];\n                    _swrs[id] = {\n                        data: swr.data,\n                        error: swr.error,\n                        revalidate: swr.revalidate,\n                        isValidating: swr.isValidating,\n                        mutate: swr.mutate\n                    };\n                    return _swrs;\n                });\n                if (typeof swr.data !== 'undefined') {\n                    // set next page's offset\n                    const newPageOffset = SWRToOffset(swr, id);\n                    if (pageOffsets[id + 1] !== newPageOffset) {\n                        setPageOffsets(arr => {\n                            const _arr = [...arr];\n                            _arr[id + 1] = newPageOffset;\n                            cacheSet(pageOffsetKey, _arr);\n                            return _arr;\n                        });\n                    }\n                }\n            }\n            return swr;\n        };\n        // render each page\n        const p = [];\n        if (!pageCacheMap.has(pageKey)) {\n            pageCacheMap.set(pageKey, []);\n        }\n        const pageCache = pageCacheMap.get(pageKey);\n        for (let i = 0; i < pageCount; ++i) {\n            if (!pageCache[i] ||\n                pageCache[i].offset !== pageOffsets[i] ||\n                pageCache[i].pageFn !== _pageFn) {\n                // when props change or at init\n                // render the page and cache it\n                pageCache[i] = {\n                    component: (React.createElement(Page, { key: `page-${pageOffsets[i]}-${i}`, offset: pageOffsets[i], withSWR: getWithSWR(i) })),\n                    pageFn: _pageFn,\n                    offset: pageOffsets[i]\n                };\n            }\n            p.push(pageCache[i].component);\n        }\n        return p;\n    }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n    return {\n        pages,\n        pageCount,\n        pageSWRs,\n        isLoadingMore,\n        isReachingEnd,\n        isEmpty,\n        loadMore\n    };\n}\n"]},"metadata":{},"sourceType":"module"}